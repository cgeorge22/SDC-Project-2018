public class BinaryNode <T> {

  private T data;
  private BinaryNode<T> left;
  private BinaryNode<T> right;

  public static void main(String[] args) {
    BinaryNode<String> root = new BinaryNode<>("Durian",
        new BinaryNode<>("Banana", new BinaryNode<>("Apple"), new BinaryNode<>("Cherry")),
        new BinaryNode<>("Fig", new BinaryNode<>("Elderberry"), new BinaryNode<>("Grape")));

    // What does this print out?
    //System.out.println(root.getLeft().getRight().getData());
    // How does this change our binary tree structure/diagram?
    //root.getRight().getLeft().setRight(new BinaryNode<>("Something New!"));
    
    insert(root, new BinaryNode<>("Blueberry"));
    // test to check whether Blueberry is inserted in the expected position:
    System.out.println(root.getLeft().getRight().getLeft().getData());
    
    System.out.println( root.toString() ); // begin to discuss traversal orders
    // Notice that the order that nodes are printed out matched the declaration above.
  }

  // this static insert method only works on BinaryNodes that contain Comparable data:
  public static <E extends Comparable<E>> void insert(BinaryNode<E> treeNode, BinaryNode<E> newNode) {
    int comparison = newNode.getData().compareTo( treeNode.getData() );
    if(comparison == 0) // we're not allowing nodes with duplicate data to be added
      throw new IllegalStateException("Nodes with duplicate data cannot be added to this BST.");
    else if(comparison < 0) { // insert newNode into the left subtree beneath treeNode
      if(treeNode.getLeft() == null) // Base case is when left subtree is empty:
        treeNode.setLeft(newNode);   // make newNode the new left subtree, in this case.
      else // other wise make a recursive call to insert within that left subtree:
        insert(treeNode.getLeft(),newNode);
    } else { // insert newNode into the right subtree beneath treeNode (mirrors logic above)
      if(treeNode.getRight() == null)
        treeNode.setRight(newNode);
      else
        insert(treeNode.getRight(),newNode);
    }
  }

  @Override
  public String toString() {
    String s = "";
    // pre-order traversal: visit, left, right
    // post-order traversal: left, right, visit
    // in-order traversal: left, visit, right
//    if(left != null)  s += " " + left.toString();
//    s += " " + data.toString();
//    if(right != null) s += " " + right.toString();
    
    // level- order traversal: top to bottom, left to right within each depth
    //QueueADT<BinaryNode<T>> q = new LinkedQueue<>();
    return s;
  }
  
  public BinaryNode(T data) { this(data,null,null); }
  // code below this point autogenerated by eclipse:
  public BinaryNode(T data, BinaryNode<T> left, BinaryNode<T> right) {
    super();
    this.data = data;
    this.left = left;
    this.right = right;
  }
  public T getData() {
    return data;
  }
  public void setData(T data) {
    this.data = data;
  }
  public BinaryNode<T> getLeft() {
    return left;
  }
  public void setLeft(BinaryNode<T> left) {
    this.left = left;
  }
  public BinaryNode<T> getRight() {
    return right;
  }
  public void setRight(BinaryNode<T> right) {
    this.right = right;
  }
}